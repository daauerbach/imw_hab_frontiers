---
title: "Frontiers manuscript figures and tables"
author: "dan.auerbach@dfw.wa.gov"
date: "`r Sys.Date()`"
format:
  docx:
    reference-doc: /Users/auerbdaa/O/code/quarto_template.docx
  html:
    embed-resources: true
    theme: yeti 
    code-fold: true
    toc: true
    toc-location: left
    grid:
      sidebar-width: 180px
      body-width: 1100px
      margin-width: 20px
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 10)

library("tidyverse", quietly = T)
library("sf")
library("patchwork")
library("gt")
theme_set(theme_minimal()) 

# dir_data_common <- "~/T/DFW-Team WDFW Watershed Synthesis - data_common"
# epsg <- 2927 #WA state standard; NAD83(HARN)/ft

#load("~/T/DFW-Team WDFW Watershed Synthesis - IMW analyses/imw_hab_250307.RData")
load("~/T/DFW-Team WDFW Watershed Synthesis - IMW analyses/imw_hab_251203.RData") #pool_weth_depth and pool_bnk_depth; no new EMAP query

```


```{r figMAP_stream_sites_placeholder, fig.cap="Western Washington IMW stream habitat monitoring sites for Hood Canal (a,d), Lower Columbia (b,e), and Strait of Juan de Fuca (c,f) complexes. Stavis, Mill and West Twin creeks were designated as control watersheds in original study design."}

bsmp_str <- map(
  set_names(unique(sf_site_meta$cmplx_desc))
  ,
  ~maptiles::get_tiles(
    st_as_sfc(st_bbox(sf_site_meta |> filter(cmplx_desc == .x))) |> st_buffer(5000),
    #provider = "OpenStreetMap",
    provider = "Esri.WorldStreetMap",
    crop = TRUE
  )
)

bsmp_img <- map(
  set_names(unique(sf_site_meta$cmplx_desc))
  ,
  ~maptiles::get_tiles(
    st_as_sfc(st_bbox(sf_site_meta |> filter(cmplx_desc == .x))) |> st_buffer(5000),
    provider = "Esri.WorldImagery",
    crop = TRUE
  )
)

bsmp_top <- map(
  set_names(unique(sf_site_meta$cmplx_desc))
  ,
  ~maptiles::get_tiles(
    st_as_sfc(st_bbox(sf_site_meta |> filter(cmplx_desc == .x))) |> st_buffer(5000),
    provider = "OpenTopoMap",
    crop = TRUE
  )
)

wrap_plots(map(
  unique(sf_site_meta$cmplx_desc)
  ,
  ~ggplot() + 
    tidyterra::geom_spatraster_rgb(data = bsmp_str[[.x]]) +
    geom_sf(data = sf_site_meta |> filter(cmplx_desc == .x), aes(color = strm), show.legend = F) +
    geom_sf_text(
      data = sf_site_meta |> 
        filter(cmplx_desc == .x) |> 
        #mutate(strm = as.character(strm)) |> 
        group_by(strm) |> summarize() |> st_centroid(),
      mapping = aes(label = strm, color = strm), show.legend = F) +
    scale_color_manual(values = pal_strm) +
    ggspatial::annotation_scale() +
    theme_void()
), ncol = 1) -
  wrap_plots(map(
  unique(sf_site_meta$cmplx_desc)
  ,
  ~ggplot() + 
    tidyterra::geom_spatraster_rgb(data = bsmp_img[[.x]]) +
    geom_sf(data = sf_site_meta |> filter(cmplx_desc == .x), color = "orange") +
    ggspatial::annotation_scale() +
    theme_void()
), ncol = 1) +
  plot_annotation(tag_levels = "a")

#   wrap_plots(map(
#   unique(sf_site_meta$cmplx_desc)
#   ,
#   ~ggplot() + 
#     tidyterra::geom_spatraster_rgb(data = bsmp_top[[.x]]) +
#     geom_sf(data = sf_site_meta |> filter(cmplx_desc == .x), color = "orange") +
#     ggspatial::annotation_scale() +
#     theme_void()
# ), ncol = 1) 

```

```{r tabStrmMetadata}
site_meta |> 
  summarise(
    n_site = n(),
    across(year_n, median),
    across(n_tsct_tot, sum),
    .by = c(cmplx_desc, strm)
  ) |>
  mutate(
    `Treatment/Control` = if_else(str_detect(strm, "Stavis|Mill|West"), "control", "treatment")
    ,colfill = alpha(pal_strm[strm], 0.7)
    ) |> 
  select(cmplx_desc, strm, colfill, `Treatment/Control`,
         Sites = n_site, `Median years/site` = year_n, `Total transects` = n_tsct_tot) |> 
  gt(groupname_col = "cmplx_desc", rowname_col = "strm") |> 
  cols_hide(columns = "colfill") |> 
  fmt_number(columns = where(is.numeric), decimals = 0) |> 
  tab_style(
    style = cell_fill(color = from_column("colfill")), locations = cells_body()
  )

```

# data

```{r emap_pull, echo=FALSE, eval=FALSE}
#declare 'con_emap' odbc::dbConnect
library(tidyverse)

emap <- list()

# rows per year, site metadata: location, length, etc.
# limiting to sampled, 2007 forward
# replacing -9999s with NA
emap$reaches_sampled <- tbl(
  con_emap,
  dbplyr::in_schema("dbo", "ZCORE_Reaches_All_V")
  ) |>
  filter(
    Sampl_Or_Not_Ind == 1,
    Srvy_Yr > 2006
    ) |>
  select(
    cmplx_abrv = COMPLEX_NAME_Abrvd,
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Site_Id,
    Reach_Survey_Id,
    x_lat = Xsite_Lat_Coord,
    x_lon = Xsite_Lngtd_Coord,
    smpl_mthd_desc = SAMPL_METHOD_Desc,
    rch_lgth_meas_desc = REACH_LNGTH_MEAS_LOC_Desc,
    Xsite_Distnc_Up_Meas, Xsite_Distnc_Down_Meas
    #STREAM_NAME_LLID_100_Code, Total_Reach_Lgth, Move_Reach_Ind
  ) |>
  collect() |>
  rename_with(tolower) |>
  mutate(
    across(
      c(xsite_distnc_up_meas, xsite_distnc_down_meas),
      ~if_else(. < 0, NA_integer_, .)
    ),
    up_down_lgth = xsite_distnc_up_meas + xsite_distnc_down_meas
  )


#bankfull, wetted width, thalweg depth, size channels, bars, etc.
#usually ~21 transects per site per year
#limited to 2007 forward, replacing -9999 with NAs
#dropping 'code' LU fields, 'verify' date & time, crewname
emap$transects <- tbl(
  con_emap,
  dbplyr::in_schema("dbo", "ZCORE_Transects_V")
  ) |>
  filter(
    Srvy_Yr > 2006
  ) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    x_lat = Xsite_Lat_Coord,
    x_lon = Xsite_Lngtd_Coord,
    Transect_Id, Transect_Letter,
    Transect_Extra_Side_Channel_Ind,
    Transect_Fish_Present_Ind,
    Transect_Wet_Wdth_Meas,
    Transect_Bar_Wdth_Present_Ind, Transect_Bar_Wdth_Meas,
    Transect_Bankfull_Wdth_Meas, Transect_Bankfull_Hgt_Meas,
    Transect_Thalweg_Dpth_Meas,
    CHANNEL_UNIT_CODE_Abrvd, CHANNEL_UNIT_CODE_Desc, #,Transect_Channel_Unit_Code,
    POOL_FORM_CODE_Desc, #,Transect_Pool_Form_Code,
    Transect_Backwater_Present_Ind,
    Pool_Non_Pool_Desc #,Pool_Non_Pool_Code,
  ) |>
  collect() |>
  rename_with(tolower) |>
  drop_na(transect_id) |>
  mutate(
    across(
      c(ends_with("_meas")),
      ~if_else(. < 0, NA_real_, .)
    )
  )

#usually 5 substrate measures per transect, ~21 transects per site per year
#limited to 2007 forward, replacing -9999 with NAs
emap$substrate <- tbl(
  con_emap,
  dbplyr::in_schema("dbo", "ZCORE_Transects_Substrate_V")
  ) |>
  filter(Srvy_Yr > 2006) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    Transect_Id, Transect_Letter,
    CHANNEL_UNIT_CODE_Abrvd, #,Transect_Channel_Unit_Code,
    Transect_Substrate_Id,
    TRANSECT_SUBSTRATE_SAMPL_PT_Abrvd, #,TRANSECT_SUBSTRATE_SAMPL_PT_Code,
    Transect_Substrate_Sampl_Dpth_Meas,
    TRANSECT_SUBSTRATE_SIZE_CLAS_Abrvd, TRANSECT_SUBSTRATE_SIZE_CLAS_Desc #,TRANSECT_SUBSTRATE_SIZE_CLAS_Code
  ) |>
  collect() |>
  rename_with(tolower) |>
  mutate(
    across(
      c(ends_with("_meas")),
      ~if_else(. < 0, NA_real_, .)
    )
  )

#measured for 'segments' between (x-section) transects
#counts for multiple length and diameter classes, in-channel and 'bridging'
#no coercion to NA (yet)
emap$lwd <- tbl(
  con_emap,
  dbplyr::in_schema("dbo", "ZCORE_ReachSegments_LWD_V")
  ) |> #colnames()
  filter(Srvy_Yr > 2006) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    everything()
  ) |>
  collect() |>
  drop_na(LWD_CLAS_Code) |>
  rename_with(~str_remove(.,"LWD_CLAS_"), contains("LWD_CLAS_")) |>
  rename_with(tolower)

glimpse(emap)

DBI::dbDisconnect(con_emap)
rm(uid, pwd, con_emap)
saveRDS(emap, "emap_pull.rds")

```

```{r build_envi, echo=FALSE, eval=FALSE}
#this chunk rebuilds the environment from the full query object
#  'emap' list of only raw/orig query (before raw and wrangled)
#  'hab' list of wrangled objects
#!!hab object here is NOT same as in high_var_stream_hab chunk 'build_hab'!!
# that chunk high_var_stream_hab>>build_hab has more comments on qaqc and wrangling checks

#file.info("~/O/code/imw/emap_pull.rds")['mtime']
file.info("~/T/DFW-Team WDFW Watershed Synthesis - IMW analyses/emap_pull.rds")['mtime']
emap <- readRDS("~/T/DFW-Team WDFW Watershed Synthesis - IMW analyses/emap_pull.rds")
names(emap)

#plotting palettes: W to E within complex
pal_strm <- set_names(
  c(c("#3A270A", "#D3BEAF", "#965127", "#D2A554"), #"#E4C22B" 
    c("#1E212F", "#48628A", "#A4BADF"), 
    c("#254029", "#516F25", "#94AA3D")
    ),
  c('Stavis Creek*','Seabeck Creek','Big Beef Creek','Little Anderson Creek',
    'Mill Creek*','Abernathy Creek','Germany Creek',
    'Deep Creek','West Twin River*','East Twin River'))
pal_cmplx_strm <- set_names(
  pal_strm,
  c('HC_Stavis Creek*','HC_Seabeck Creek','HC_Big Beef Creek','HC_Little Anderson Creek',
    'LC_Mill Creek*','LC_Abernathy Creek','LC_Germany Creek',
    'ST_Deep Creek','ST_West Twin River*','ST_East Twin River'))

# #leaves culverts, falls, fishladders etc.
# emap$transects |> count(channel_unit_code_abrvd, channel_unit_code_desc) |> print(n=100)
transects_excluded <- c(
  "-9999", #NAs
  "IA", #~350 inaccessible
  "OT" #10 other
  ) 


hab <- list()

#### 1. location and monitoring duration metadata
hab$site_meta <- emap$reaches_sampled |>
  summarise(
    across(c(year), list(min = min, max = max)),
    year_diff = year_max - year_min + 1,
    year_n = n(),
    across(c(x_lon, x_lat), list(mean = ~mean(., na.rm = T))),
    .by = c("cmplx_abrv", "cmplx_desc", "strm", "site")
  ) |>
  mutate(
    cmplx_desc = str_replace(cmplx_desc, "Straits", "Strait"),
    strm = if_else(
      str_detect(strm, "Stavis|Mill|West"),
      paste0(strm, "*"), 
      strm) |> 
      factor(levels = names(pal_strm))
  ) |> 
  unite("cmplx_strm", cmplx_abrv, strm, remove=F) |> 
  mutate(
    cmplx_strm = factor(cmplx_strm, levels = names(pal_cmplx_strm)),
    resto_add = as.integer(str_sub(site,4,6)) > 899
  ) |> 
  arrange(cmplx_desc, strm, year_min, site) 

#### 2. clean transects, preserving 'true' supplementals and reducing to only obs used 
#primary cross-sectional transects are A:K, with intervening A2, B2
#supplementary X-Y-Z transects at the same stream-longitudinal position can occur when field crew encounter 'substantial' flow splits
#the distinct() removes ~50 cases in HC from 2007 and 2008 of transect rows that are "X|Y|Z" lettered but are exact duplicates bankfull, wetted and depth measures
hab$transects <- emap$transects |> 
  filter(!(channel_unit_code_abrvd %in% transects_excluded)) |> 
  mutate(
    cmplx_desc = str_replace(cmplx_desc, "Straits", "Strait"),
    strm = if_else(
      str_detect(strm, "Stavis|Mill|West"),
      paste0(strm, "*"), 
      strm) |> 
      factor(levels = names(pal_strm)),
    tsct_lett = str_remove_all(transect_letter, "X|Y|Z") #but retaining orig 'transect_letter'
    ) |>
  distinct(
    cmplx_desc, strm, site, year, reach_survey_id, tsct_lett,
    pool_non_pool_desc, channel_unit_code_abrvd, channel_unit_code_desc,
    transect_bankfull_wdth_meas, transect_wet_wdth_meas, transect_thalweg_dpth_meas,
    .keep_all = T
    ) |> 
  #dropping bar indicator and width
  left_join(hab$site_meta |> distinct(strm, cmplx_strm), by = "strm") |> 
  select(
    cmplx_strm, cmplx_desc, strm, site, year, reach_survey_id, x_lon, x_lat, transect_id,
    tsct_lett, transect_letter,
    side_chan = transect_extra_side_channel_ind,
    fish_prst = transect_fish_present_ind,
    bnk_wdth = transect_bankfull_wdth_meas,
    bnk_hght = transect_bankfull_hgt_meas,
    wet_wdth = transect_wet_wdth_meas,
    thl_dpth = transect_thalweg_dpth_meas,
    pool_non_pool_desc, 
    channel_unit_code_abrvd, channel_unit_code_desc
    )

#### 3. summarize site-year channel form measures and substrate
# - number/pct of 'supplemental' transects for parallel/anastomosed 'side channels' at same longitudinal cross-section
# - number/pct of intersected (categorical) pools
# - mean of (thalweg) depth of transects intersecting pools
# - pct_gravels, note this returns fewer rows than the objects based directly on hab$transects, some strm-site-year are NA esp with filter to GC/GF
# - summarize site-year sample distrib of (main+supp) bankfull width 
#   - first need to add main and supplemental widths
#   - here not distinguishing by categorical pool_non_pool or channel_unit_code to give 'full width' regardless of different 'form types'
#   - reduces to max of 21 obs per site-year at 'base letter' positions (which can be fewer than the site-year count of all transects)
# - summarize W:D across transects after first calc'ing for supplementary (XA, YA, etc.) as distinct from primary
hab$transects_site_year <- hab$transects |> 
  summarise(
    n_tsct = n(), #same as: length(transect_letter)
    n_supp = sum(str_detect(transect_letter, "X|Y|Z")),
    pct_supp = n_supp / n_tsct,
    n_pools = sum(pool_non_pool_desc == "Pool"), #includees 'Beaver Pond'
    pct_pools = n_pools / n_tsct,
    .by = c("cmplx_strm", "strm", "site", "year", "reach_survey_id")
  ) |> 
  full_join(
    hab$transects |> 
      filter(pool_non_pool_desc == "Pool") |> 
      summarise(
        pool_wet_depth_mean = mean(thl_dpth, na.rm = T),
        pool_bnk_depth_mean = mean(bnk_hght, na.rm = T),
        .by = c("strm", "site", "year", "reach_survey_id")
      ) 
    # |> filter(pool_wet_depth_mean > pool_bnk_depth_mean) 
    #9 of 4005 site-years, semi-joined shows really 10 individual transects but not possible to determine what/if error
    ,
    by = c("strm", "site", "year", "reach_survey_id")
  ) |> 
  full_join(
    emap$substrate |> 
      mutate(
        strm = if_else(
          str_detect(strm, "Stavis|Mill|West"),
          paste0(strm, "*"), 
          strm) |> 
          factor(levels = names(pal_strm))
      ) |> 
      count(strm, site, year, reach_survey_id,
            transect_substrate_size_clas_abrvd, 
            transect_substrate_size_clas_desc) |> 
      group_by(strm, site, year, reach_survey_id) |>
      mutate(n_pct = n / sum(n)) |> 
      filter(transect_substrate_size_clas_abrvd %in% c("GC", "GF")) |> 
      summarise(pct_gravel = sum(n_pct), .groups = "drop"), 
    by = c("strm", "site", "year", "reach_survey_id")
  ) |> 
  #now add width; bringing back 'wetted'
  full_join(
    hab$transects |> 
      #first sum per cross-sectional transect position, doing nothing for many non-split instances
      summarise(
        across(c(bnk_wdth, wet_wdth), sum), 
        .by = c("strm", "site", "year", "reach_survey_id", "tsct_lett")
      ) |> 
      #then aggregate to site-year distributional measures across transects
      summarise(
        across(
          c(bnk_wdth, wet_wdth),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            #med = ~median(., na.rm = T),
            max = ~max(., na.rm = T)
            #can easily calc later, leaving off until known pref to calc here
            #,trsct_cv = ~sd(., na.rm =T) / mean(., na.rm = T)
          )),
        .by = c("strm", "site", "year", "reach_survey_id")
      ), 
    by = c("strm", "site", "year", "reach_survey_id")
  ) |>  
  #now add width:depth
  #shift to wetted-thalweg, bank-bank following call with KK/WD/KS
  #summarization throws warnings whenever grouped vector is empty
  full_join(
    hab$transects |> 
      #calc W:D at every transect, including lateral 'supplementary'
      #plenty of Inf and NA
      mutate(
        wet_w_thl_d = wet_wdth / thl_dpth,
        bnk_w_bnk_d = bnk_wdth / bnk_hght
      ) |> 
      #then aggregate to site-year distributional measures across transects
      summarise(
        across(
          c(wet_w_thl_d, bnk_w_bnk_d),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            max = ~max(., na.rm = T)
          )),
        .by = c("strm", "site", "year", "reach_survey_id")
      ) 
    ,
    by = c("strm", "site", "year", "reach_survey_id")
  ) 

#### 4. summarize site-year large wood densities
#per transect, 3 length and 4 diameter classes for 2 position bridging & inchan
#always recording counts within each crossing level, including 0s
#past practice to drop smallest and shortest then sum counts over other levels
# emap$lwd |> count(diameter_code, diameter_desc, lgth_code, lgth_desc)
#    diameter_code diameter_desc lgth_code lgth_desc     n
#            <int> <chr>             <int> <chr>     <int>
#  1            10 0.1 - 0.3 m          10 1.5 - 5 m 86180
#  2            10 0.1 - 0.3 m          20 5 - 15 m  86180
#  3            10 0.1 - 0.3 m          30 >15 m     86180
#  4            20 0.3 - 0.6 m          10 1.5 - 5 m 86180
#  5            20 0.3 - 0.6 m          20 5 - 15 m  86180
#  6            20 0.3 - 0.6 m          30 >15 m     86180
#  7            30 0.6 - 0.8 m          10 1.5 - 5 m 86180
#  8            30 0.6 - 0.8 m          20 5 - 15 m  86180
#  9            30 0.6 - 0.8 m          30 >15 m     86180
# 10            40 >0.8 m               10 1.5 - 5 m 86180
# 11            40 >0.8 m               20 5 - 15 m  86180
# 12            40 >0.8 m               30 >15 m     86180
#here:
# - combining 'AlI/Part In' and 'Bridged Above'
# - aggregate over segments per stream-year
# - join site-year lengths calc'd from the up+down lengths
#    - NOW no missing following WD/KS additional qaqc: emap$reaches_sampled |> filter(is.na(up_down_lgth))
# - and NOW join site-year mean bankfull width to get areal density
#    - introducing error with "area = total_length * average_width", presumably greater with more sinuosity?
#       but preferably simpler than attempting trapezoidal calc from top/bottom transect & per-segement lengths
#       not even clear that per-segment length from 'compass-distance' table would be suitable?
# - retaining 'all' as well as larger classes; pre-2024 filtered diameter_code & lgth_code > 10, #more than 0.3m dia and 5m long
hab$lwd_site_year <- emap$lwd |>
  #count(diameter_code, diameter_desc, lgth_code, lgth_desc)
  #coerce -9999 to NA
  mutate(
    strm = if_else(
      str_detect(strm, "Stavis|Mill|West"),
      paste0(strm, "*"), 
      strm) |> 
      factor(levels = names(pal_strm)),
    lwd_cnt = if_else(lwd_cnt < 0, NA_integer_, lwd_cnt)
    ,
    diameter_code = paste0("d", diameter_code),
    lgth_code = paste0("l", lgth_code)
    ) |> 
  unite("diam_lgth", diameter_code, lgth_code) |> 
  summarise(
    #n_seg = length(reach_segment_id),
    tot_lwd_cnt = sum(lwd_cnt, na.rm=T)
    , .by = c("strm", "site", "year", "reach_survey_id",
              "diam_lgth" #"diameter_code", "lgth_code"
              )
  ) |>
  pivot_wider(names_from = diam_lgth, values_from = tot_lwd_cnt) |> 
  left_join(
    emap$reaches_sampled |> 
      select(site, year, reach_survey_id, up_down_lgth)
    , by = c("site", "year", "reach_survey_id")
  ) |> 
  left_join(
    hab$transects_site_year |> 
      select(site, year, reach_survey_id, bnk_wdth_mean)
    , by = c("site", "year", "reach_survey_id")
  ) |> 
  mutate(
    lwd_all = d10_l10 + d10_l20 + d10_l30 + 
              d20_l10 + d20_l20 + d20_l30 + 
              d30_l10 + d30_l20 + d30_l30 + 
              d40_l10 + d40_l20 + d40_l30
    ,
    lwd_no10 = d20_l20 + d20_l30 + 
               d30_l20 + d30_l30 + 
               d40_l20 + d40_l30
    ,
    lgth_wdth = up_down_lgth * bnk_wdth_mean
    ,
    across(starts_with("lwd"),
           list(
             per100 = ~100 * (. / up_down_lgth)
             ,
             per_m2 = ~(. / lgth_wdth)
             ))
    ,
    #using lower bounds of size classes for more conservative estimate?
    vlwd_vol = d20_l20 * (pi * 0.15^2 * 5) + 
      d20_l30 * (pi * 0.15^2 * 15) + 
      d30_l20 * (pi * 0.3^2 * 5) + 
      d30_l30 * (pi * 0.3^2 * 15) + 
      d40_l20 * (pi * 0.4^2 * 5) + 
      d40_l30 * (pi * 0.4^2 * 15)
  ) |>
  #exclusions per WD/KS: "QC_RchMeasXsiteDstVsCmpDst_Extrc_Null_XsiteDistances.xlsx"
  filter(
    !(year == 2019 & site %in% c(
      "DEW017","DEW034","DEW073","DEW097","DEW113","DEW125",
      "DEW273","DEW287","DEW317","DEW477","DEW026","DEW044",
      "DEW067","DEW110","DEW158","DEW170","DEW630","DEW014",
      "DEW027","DEW057","DEW080","DEW322"
    ))
  )


#### 5. sites to include
hab$incl_sites <- hab$site_meta |> #287
  #filter(year_n >= 10) #251
  filter(year_n > 3 & year_n/year_diff > 0.5) |> arrange(year_n) |> #print(n=20) #269, adds mostly newer/recent but consistent sites
  select(site)
# #excluded
# emap$reaches_sampled |>
#   summarise(
#     across(c(year), list(min = min, max = max)),
#     year_diff = year_max - year_min + 1,
#     year_n = n(),
#     .by = c("cmplx_abrv", "cmplx_desc", "strm", "site")
#   ) |> 
#   anti_join(
#     hab$incl_sites, by = "site"
#   ) |> 
#   arrange(cmplx_desc, year_n)

hab$site_meta |> count(year_n) |> arrange(desc(year_n))

#### 6. summarize measures across years per site and add back to site_meta
#first filtering to included sites
#then expanding to complete years per site-stream for explicit missing vals
#coercing Inf to NA (NaN already gets treated as NA)
#warnings are legit due to missing vals and/or irrelevant due dropping sites with few obs in primary semi_join
#preserves only mean-over-years of within-year mean-over-transects
#could add back median-over-years of within-year median-over-transects but examined diffs were qualitatively insignif
hab$site_meta <- hab$site_meta |> 
  semi_join(hab$incl_sites, by = "site") |> 
  left_join(
    hab$transects_site_year |> 
      #semi_join not needed due to left_join but could uncomment for intermediate inspection: semi_join(hab$incl_sites, by = "site") |> 
      group_by(site) |> 
      complete(year = min(hab$site_meta$year_min):max(hab$site_meta$year_max)) |> 
      ungroup() |> #glimpse()
      mutate(across(where(is.numeric), \(x){ x[is.infinite(x)] <- NA; return(x)})) |> 
      summarise(
        across(c(n_tsct, n_supp), list(tot = ~sum(.,na.rm = T))),
        pct_supp = n_supp_tot / n_tsct_tot,
        across(
          c(
            bankfull_width = bnk_wdth_mean,
            wetted_width = wet_wdth_mean,
            bankfull_W_D = bnk_w_bnk_d_mean,
            wetted_W_D = wet_w_thl_d_mean,
            pct_gravel, 
            pct_pools, 
            #pool_depth = pool_depth_mean
            pool_wet_depth = pool_wet_depth_mean,
            pool_bnk_depth = pool_bnk_depth_mean
            ),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            max = ~max(., na.rm = T)
          )), .by = "site") 
    , by = "site"
  ) |> 
  left_join(
    hab$lwd_site_year |>
      group_by(site) |> 
      complete(year = min(hab$site_meta$year_min):max(hab$site_meta$year_max)) |> 
      ungroup() |> #glimpse() #no Inf
      summarise(
        lgth_mean = mean(up_down_lgth, na.rm = T),
        lgth_wdth_mean = mean(lgth_wdth, na.rm = T),
        across(
          c(
            lwd_all, lwd_all_per100, lwd_all_per_m2,
            vlwd = lwd_no10, 
            vlwd_per100 = lwd_no10_per100,
            vlwd_per_m2 = lwd_no10_per_m2,
            vlwd_vol
          ),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            max = ~max(., na.rm = T)
          )), .by = "site")
    , by = "site"
  ) |>
  #mostly already clean, but coerce a few bankfull_W_D Infs to NA
  mutate(across(where(is.numeric), \(x){ x[is.infinite(x)] <- NA; return(x)})) 

#### 7. measures by site-year for included sites
#keeping only per-year means across transects where applicable
#and again completing site-year cases for explicit missing during full study duration
#and coercing Inf to NA
hab$site_year <- left_join(
  hab$transects_site_year,
  hab$lwd_site_year |> select(-bnk_wdth_mean),
  by = c("strm","site","year","reach_survey_id")
  ) |> 
  semi_join(hab$incl_sites, by = "site") |> 
  select(
    cmplx_strm, strm, site, year, reach_survey_id, n_tsct, n_supp, pct_supp, 
    bankfull_width = bnk_wdth_mean,
    wetted_width = wet_wdth_mean,
    bankfull_W_D = bnk_w_bnk_d_mean,
    wetted_W_D = wet_w_thl_d_mean,
    pct_gravel, 
    pct_pools, 
    #pool_depth = pool_depth_mean,
    pool_wet_depth = pool_wet_depth_mean,
    pool_bnk_depth = pool_bnk_depth_mean,
    up_down_lgth, lgth_wdth,
    lwd_all, lwd_all_per100, lwd_all_per_m2,
    vlwd = lwd_no10, 
    vlwd_per100 = lwd_no10_per100,
    vlwd_per_m2 = lwd_no10_per_m2,
    vlwd_vol
  ) |> #summary()
  group_by(cmplx_strm, strm, site) |> 
  complete(year = min(hab$site_meta$year_min):max(hab$site_meta$year_max)) |> 
  ungroup() |> #summary() #glimpse()
  mutate(across(where(is.numeric), \(x){ x[is.infinite(x)] <- NA; return(x)})) 


#### 8. site-year measures made spatial 
#but reduced to only sampled cases due to need for lon/lat
hab$sf_site_year <- hab$site_year |>
  left_join(
    emap$reaches_sampled |> select(site, year, x_lon, x_lat), 
    by = c("site","year")
  ) |> 
  drop_na(x_lon) |> 
  sf::st_as_sf(coords = c("x_lon", "x_lat"), crs = sf::st_crs(4326)) |> 
  sf::st_transform(sf::st_crs(2927)) #NAD83 HARN WA ft


#### final 'clean' objects broken from list for EDA and fitting
#left as extra step to allow last minute wrangling while preserving upstream hab-list versions
site_meta <- hab$site_meta 
sf_site_meta <- site_meta |>
  st_as_sf(coords = c("x_lon_mean", "x_lat_mean"), crs = sf::st_crs(4326)) |>
  sf::st_transform(sf::st_crs(2927))
site_year <- hab$site_year
sf_site_year <- hab$sf_site_year
#whole-stream per-year distributional moments across sites[year]
#distinct from per-site summaries across years in hab$site_meta
#declaration begins from already-site-filtered object
strm_year <- site_year |>  #as_tibble(sf_site_year) |> 
  summarise(
    n_site_with_bnk = length(na.omit(bankfull_width)),
    across(
      c(
        bankfull_width,
        bankfull_W_D,
        pct_gravel, 
        pct_pools, 
        pool_wet_depth, pool_bnk_depth, #pool_depth,
        up_down_lgth,
        lwd_all, lwd_all_per100, lwd_all_per_m2,
        vlwd, vlwd_per100, vlwd_per_m2,
        vlwd_vol
        ),
      list(
        min = ~min(., na.rm = T),
        q25 = ~quantile(., p = 0.25, na.rm = T),
        q50 = ~median(., na.rm =T),
        mean = ~mean(., na.rm = T),
        q75 = ~quantile(., p = 0.75, na.rm = T),
        max = ~max(., na.rm = T)
      )
    )
    , .by = c("cmplx_strm", "year")
  )

rm(emap)

save.image(file = paste0("~/T/DFW-Team WDFW Watershed Synthesis - IMW analyses/imw_hab_",str_remove_all(Sys.Date(),"-") |> str_sub(3,8),".RData"))

```

# uncertainty in measures

## bankfull pool depth vs wetted pool depth

```{r wet_vs_bnk_pool_depth}

#whole-stream pool bankfull depth is roughly about as variable among years as pool wetted depth (first two plots)
#the coefficients of variation through time for individual sites show that the average bankfull pool depth was lower than the average wetted pool depth in all streams but W Twin, but that the distribution of CV were not meaningfully different outside of Seabeck (where wetted was much more variable, as expected) and maaaaaybe Mill or Germany (third plot of boxes)
#subtracting the per-site bankfull depth CV from the wetted depth CV shows most sites had more variation through time in wetted (last plot, right of 0 line) but the differences were small especially outside of Seabeck, Anderson and ABR016 and STA015

strm_year |> 
  select(cmplx_strm, year, pool_wet_depth_mean, pool_bnk_depth_mean) |> 
  pivot_longer(-c(cmplx_strm, year)) |> 
  
  # ggplot(aes(year, value, color = cmplx_strm)) +
  # scale_color_manual(values = pal_cmplx_strm) +
  # geom_line(aes(linetype = name)) + geom_point(aes(shape = name)) +
  # facet_grid(rows = vars(cmplx_strm))

  ggplot(aes(year, value, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  geom_line(aes(linetype = name)) + geom_point(aes(shape = name)) +
  facet_grid(cols = vars(name))

site_meta |> 
  select(cmplx_strm, site, 
         pool_wet_depth_mean, pool_wet_depth_sd, 
         pool_bnk_depth_mean, pool_bnk_depth_sd) |> 
  mutate(
    pool_wet_depth_cv = pool_wet_depth_sd / pool_wet_depth_mean,
    pool_bnk_depth_cv = pool_bnk_depth_sd / pool_bnk_depth_mean
  ) |> 
  select(cmplx_strm, site, ends_with("cv")) |> 
  pivot_longer(-c(cmplx_strm, site)) |> 
  ggplot(aes(value, name, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  geom_boxplot(aes(fill = name), outliers = F) +
  geom_jitter(aes(shape = name),  height = 0.2) +
  facet_grid(rows = vars(cmplx_strm))


site_meta |> 
  # select(cmplx_strm, site, pool_wet_depth_sd, pool_bnk_depth_sd) |> 
    select(cmplx_strm, site, 
         pool_wet_depth_mean, pool_wet_depth_sd, 
         pool_bnk_depth_mean, pool_bnk_depth_sd) |> 
  mutate(
    pool_wet_depth_cv = pool_wet_depth_sd / pool_wet_depth_mean,
    pool_bnk_depth_cv = pool_bnk_depth_sd / pool_bnk_depth_mean,
    d_wet_bnk_cv = pool_wet_depth_cv - pool_bnk_depth_cv
  ) |> 
  drop_na(d_wet_bnk_cv) |> 
  ggplot(aes(d_wet_bnk_cv, fct_reorder(site, d_wet_bnk_cv, min, .desc = T), color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  geom_point() +
  geom_text(aes(label = site), hjust = -0.2, size = 2) +
  geom_vline(xintercept = 0)

```

## focal site series, low vs high variation

pending focal sites from WD and KK

```{r site_low_high_variation}

bind_rows( 
  semi_join(site_year, site_meta |> slice_max(pct_gravel_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "max-sd")
  ,
  semi_join(site_year, site_meta |> slice_min(pct_gravel_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "min-sd")  
  ) |> 
  mutate(sdtype = factor(sdtype, levels = c("min-sd","max-sd"))) |> 
  ggplot(aes(year, pct_gravel, group = site, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  #geom_col() +
  geom_line(linewidth = 0.3, show.legend = F) + geom_point(size = 0.5, show.legend = F) +
  facet_grid(rows = vars(cmplx_strm), cols = vars(sdtype), ) +
  labs(
    title = "Sites per stream with smallest (min-sd) and largest (max-sd) interannual variation in proportion gravel measures"
  ) +
  theme_light()

bind_rows( 
  semi_join(site_year, site_meta |> slice_max(pool_bnk_depth_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "max-sd")
  ,
  semi_join(site_year, site_meta |> slice_min(pool_bnk_depth_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "min-sd")  
  ) |> 
  mutate(sdtype = factor(sdtype, levels = c("min-sd","max-sd"))) |> 
  ggplot(aes(year, pool_bnk_depth, group = site, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  #geom_col() +
  geom_line(linewidth = 0.3, show.legend = F) + geom_point(size = 0.5, show.legend = F) +
  facet_grid(rows = vars(cmplx_strm), cols = vars(sdtype), scales = "free") +
  labs(
    title = "Sites per stream with smallest (min-sd) and largest (max-sd) interannual variation in pool form depth relative to bankfull"
  ) +
  theme_light()

bind_rows( 
  semi_join(site_year, site_meta |> slice_max(vlwd_per100_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "max-sd")
  ,
  semi_join(site_year, site_meta |> slice_min(vlwd_per100_sd, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(sdtype = "min-sd")  
  ) |> 
  mutate(sdtype = factor(sdtype, levels = c("min-sd","max-sd"))) |> 
  ggplot(aes(year, vlwd_per100, group = site, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  #geom_col() +
  geom_line(linewidth = 0.3, show.legend = F) + geom_point(size = 0.5, show.legend = F) +
  facet_grid(rows = vars(cmplx_strm), cols = vars(sdtype), scales = "free") +
  labs(
    title = "Sites per stream with smallest (min-sd) and largest (max-sd) interannual variation in very large wood count per 100m"
  ) +
  theme_light()

#as range and with site label
d <- bind_rows( 
  semi_join(site_year, site_meta |> slice_max(vlwd_per100_max - vlwd_per100_min, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(type = "max-rng")
  ,
  semi_join(site_year, site_meta |> slice_min(vlwd_per100_max - vlwd_per100_min, n = 4, by = cmplx_strm), by = "site") |> 
    mutate(type = "min-rng")  
  ) |> 
  mutate(type = factor(type, levels = c("min-rng","max-rng")))

d |> 
  ggplot(aes(year, vlwd_per100, group = site, color = cmplx_strm)) +
  scale_color_manual(values = pal_cmplx_strm) +
  geom_line(linewidth = 0.3, show.legend = F) + geom_point(size = 0.5, show.legend = F) +
  #annotate("text")
  geom_text(
    data = distinct(d, cmplx_strm, site, type, .keep_all = T) |> 
      mutate(ypos = rank(vlwd_per100, ties.method = "first")*6, .by = c(cmplx_strm, type))
    ,
    aes(label = site, y = ypos), x = 2024,
    show.legend = F) +
  facet_grid(rows = vars(cmplx_strm), cols = vars(type), scales = "free") +
  labs(
    title = "Sites per stream with smallest and largest ranges of interannual variation in very large wood count per 100m"
  ) +
  theme_light()

```

## repeat sites

```{r imwvar_pull}
#declare con_imwwar

imwvar <- list()

imwvar$reaches_sampled <- tbl(
  con_imwvar,
  dbplyr::in_schema("dbo", "ZCORE_Reaches_All_V")
  ) |>
  filter(
    Sampl_Or_Not_Ind == 1,
    Srvy_Yr > 2006
    ) |>
  select(
    cmplx_abrv = COMPLEX_NAME_Abrvd,
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Site_Id,
    Reach_Survey_Id,
    x_lat = Xsite_Lat_Coord,
    x_lon = Xsite_Lngtd_Coord,
    smpl_mthd_desc = SAMPL_METHOD_Desc,
    rch_lgth_meas_desc = REACH_LNGTH_MEAS_LOC_Desc,
    Xsite_Distnc_Up_Meas, Xsite_Distnc_Down_Meas
    #STREAM_NAME_LLID_100_Code, Total_Reach_Lgth, Move_Reach_Ind
  ) |>
  collect() |>
  rename_with(tolower) |>
  mutate(
    across(
      c(xsite_distnc_up_meas, xsite_distnc_down_meas),
      ~if_else(. < 0, NA_integer_, .)
    ),
    up_down_lgth = xsite_distnc_up_meas + xsite_distnc_down_meas
  )


#bankfull, wetted width, thalweg depth, size channels, bars, etc.
#usually ~21 transects per site per year; replacing -9999 with NAs
imwvar$transects <- tbl(
  con_imwvar,
  dbplyr::in_schema("dbo", "ZCORE_Transects_V")
  ) |>
  filter(
    Srvy_Yr > 2006
  ) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    x_lat = Xsite_Lat_Coord,
    x_lon = Xsite_Lngtd_Coord,
    Transect_Id, Transect_Letter,
    Transect_Extra_Side_Channel_Ind,
    Transect_Fish_Present_Ind,
    Transect_Wet_Wdth_Meas,
    Transect_Bar_Wdth_Present_Ind, Transect_Bar_Wdth_Meas,
    Transect_Bankfull_Wdth_Meas, Transect_Bankfull_Hgt_Meas,
    Transect_Thalweg_Dpth_Meas,
    CHANNEL_UNIT_CODE_Abrvd, CHANNEL_UNIT_CODE_Desc, #,Transect_Channel_Unit_Code,
    POOL_FORM_CODE_Desc, #,Transect_Pool_Form_Code,
    Transect_Backwater_Present_Ind
    #,Pool_Non_Pool_Desc #,Pool_Non_Pool_Code,
  ) |>
  collect() |>
  rename_with(tolower) |>
  drop_na(transect_id) |>
  mutate(
    across(
      c(ends_with("_meas")),
      ~if_else(. < 0, NA_real_, .)
    )
  )

#usually 5 substrate measures per transect, ~21 transects per site per year
#limited to 2007 forward, replacing -9999 with NAs
imwvar$substrate <- tbl(
  con_imwvar,
  dbplyr::in_schema("dbo", "ZCORE_Transects_Substrate_V")
  ) |>
  filter(Srvy_Yr > 2006) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    Transect_Id, Transect_Letter,
    CHANNEL_UNIT_CODE_Abrvd, #,Transect_Channel_Unit_Code,
    Transect_Substrate_Id,
    TRANSECT_SUBSTRATE_SAMPL_PT_Abrvd, #,TRANSECT_SUBSTRATE_SAMPL_PT_Code,
    Transect_Substrate_Sampl_Dpth_Meas,
    TRANSECT_SUBSTRATE_SIZE_CLAS_Abrvd, TRANSECT_SUBSTRATE_SIZE_CLAS_Desc #,TRANSECT_SUBSTRATE_SIZE_CLAS_Code
  ) |>
  collect() |>
  rename_with(tolower) |>
  mutate(
    across(
      c(ends_with("_meas")),
      ~if_else(. < 0, NA_real_, .)
    )
  )

#measured for 'segments' between (x-section) transects
#counts for multiple length and diameter classes, in-channel and 'bridging'
#no coercion to NA (yet)
imwvar$lwd <- tbl(
  con_imwvar,
  dbplyr::in_schema("dbo", "ZCORE_ReachSegments_LWD_V")
  ) |> #colnames()
  filter(Srvy_Yr > 2006) |>
  select(
    cmplx_desc = COMPLEX_NAME_Desc,
    strm = STREAM_NAME,
    site = Site_Name,
    year = Srvy_Yr,
    Reach_Survey_Id,
    everything()
  ) |>
  collect() |>
  drop_na(LWD_CLAS_Code) |>
  rename_with(~str_remove(.,"LWD_CLAS_"), contains("LWD_CLAS_")) |>
  rename_with(tolower)

glimpse(imwvar)

DBI::dbDisconnect(con_imwvar)
rm(uid, pwd, con_imwvar)
saveRDS(imwvar, "../imwvar_pull.rds")

```

```{r var_hab_objects}
#only want 2022, 15HC+15L sites
imwvar_sites <- filter(imwvar$reaches_sampled, year > 2012) |> select(site, year)  
imwvar <- map(imwvar, ~semi_join(.x, imwvar_sites, by = c("site", "year")))

#these are only the "secondary" or "repeat" obs, not both passes
imwvar$transects |> filter(site == "ABR009") |> arrange(transect_letter) |> print(n=Inf)

hab$transects |> filter(site == "ABR009", year == 2022) |> arrange(transect_letter) |> print(n=Inf) #24
hab$transects_site_year |> filter(site == "ABR009", year == 2022) #with sd/min/max across transects
hab$site_year |> filter(site == "ABR009", year == 2022) #site-year mean only but with LWD
site_year |> filter(site == "ABR009", year == 2022) #same as hab$site_year

#distinct() in hab$transects not needed (checked)
#also pool_non_pool is missing from original dbo_ZCORE_Transects_V
#so generating equivalent, but note that all 'unknown, fluvial' have PL channel unit codes
imwvar$transects <- imwvar$transects |>
  mutate(
    tsct_lett = str_remove_all(transect_letter, "X|Y|Z"),
    #this codes all 'unknown, fluvial' as pool==T
    pool = str_detect(pool_form_code_desc, "Not", negate = T),
    #so revert any that are not "PL" etc to pool==F
    #but turns out that all unknown are PL...
    pool = if_else(
      pool_form_code_desc == "Unknown, fluvial" & 
        str_sub(channel_unit_code_abrvd,1,1) != "P",
      F, pool)
  ) |> 
  #count(pool, pool_form_code_desc, channel_unit_code_abrvd)
  select(
    #cmplx_strm, cmplx_desc, strm, 
    site, year, reach_survey_id, x_lon, x_lat, transect_id,
    tsct_lett, transect_letter,
    side_chan = transect_extra_side_channel_ind,
    fish_prst = transect_fish_present_ind,
    bnk_wdth = transect_bankfull_wdth_meas,
    bnk_hght = transect_bankfull_hgt_meas,
    wet_wdth = transect_wet_wdth_meas,
    thl_dpth = transect_thalweg_dpth_meas,
    # #pool_non_pool_desc, ## not in these data
    # pool_form_code_desc, ## not binary
    pool,
    channel_unit_code_abrvd, channel_unit_code_desc
    )
  
#could do transect-level comparison
#but shows that not all transects were re-positioned identically
#so maybe less useful than understanding site-year uncertainty, 
#which includes both that positional uncertainty and the repeat obs (of same location) uncertainty
var_hab_tsct <- imwvar$transects |> 
  left_join(
    hab$transects |> mutate(pool = if_else(pool_non_pool_desc=="Pool", T, F))
    ,
    suffix = c("_var","_hab"),
    by = c("site", "year","tsct_lett","transect_letter")
  ) |>
  #dropping: -starts_with("reach_survey_id"), -starts_with("transect_id"), -starts_with("x_"), -cmplx_desc, -strm
  select(
    cmplx_strm, site, year, tsct_lett, transect_letter,
    starts_with("chann"), 
    pool_var, pool_hab, #pool_non_pool_desc
    starts_with("bnk_wdth"), starts_with("bnk_hght"),
    starts_with("wet_wdth"), starts_with("thl_dpth")
    )

#some of these non-matching codes may be "subtypes' of the same type (e.g., 2 kinds of pools)
var_hab_tsct |> count(channel_unit_code_abrvd_var == channel_unit_code_abrvd_hab) |> arrange(desc(n))
#pool/not is better but still ~23% not matching
var_hab_tsct |> count(pool_var == pool_hab) |> arrange(desc(n)) |> mutate(pct = n / sum(n))


#create object to pair with hab$transects_site_year
imwvar$transects_site_year <- imwvar$transects |> 
  summarise(
    n_tsct = n(), #same as: length(transect_letter)
    n_supp = sum(str_detect(transect_letter, "X|Y|Z")),
    pct_supp = n_supp / n_tsct,
    n_pools = sum(pool),
    pct_pools = n_pools / n_tsct,
    .by = c("site", "year", "reach_survey_id")
  ) |> 
  full_join(
    imwvar$transects |> 
      filter(pool) |> 
      summarise(
        pool_wet_depth_mean = mean(thl_dpth, na.rm = T),
        pool_bnk_depth_mean = mean(bnk_hght, na.rm = T),
        .by = c("site", "year", "reach_survey_id")
      ),
    by = c("site", "year", "reach_survey_id")
  ) |> 
  full_join(
    imwvar$substrate |> 
      count(site, year, reach_survey_id,
            transect_substrate_size_clas_abrvd, 
            transect_substrate_size_clas_desc) |> 
      group_by(site, year, reach_survey_id) |>
      mutate(n_pct = n / sum(n)) |> 
      filter(transect_substrate_size_clas_abrvd %in% c("GC", "GF")) |> 
      summarise(pct_gravel = sum(n_pct), .groups = "drop"), 
    by = c("site", "year", "reach_survey_id")
  ) |> 
  #now add width; bringing back 'wetted'
  full_join(
    imwvar$transects |> 
      #first sum per cross-sectional transect position, doing nothing for many non-split instances
      summarise(
        across(c(bnk_wdth, bnk_hght, wet_wdth), sum), 
        .by = c("site", "year", "reach_survey_id", "tsct_lett")
      ) |> 
      #then aggregate to site-year distributional measures across transects
      summarise(
        across(
          c(bnk_wdth, bnk_hght, wet_wdth),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            max = ~max(., na.rm = T)
          )),
        .by = c("site", "year", "reach_survey_id")
      ), 
    by = c("site", "year", "reach_survey_id")
  ) |>  
  #now add width:depth
  #shift to wetted-thalweg, bank-bank following call with KK/WD/KS
  #summarization throws warnings whenever grouped vector is empty
  full_join(
    imwvar$transects |> 
      #calc W:D at every transect, including lateral 'supplementary'
      #plenty of Inf and NA
      mutate(
        wet_w_thl_d = wet_wdth / thl_dpth,
        bnk_w_bnk_d = bnk_wdth / bnk_hght
      ) |> 
      #then aggregate to site-year distributional measures across transects
      summarise(
        across(
          c(wet_w_thl_d, bnk_w_bnk_d),
          list(
            mean = ~mean(., na.rm = T),
            sd = ~sd(., na.rm = T),
            min = ~min(., na.rm = T),
            max = ~max(., na.rm = T)
          )),
        .by = c("site", "year", "reach_survey_id")
      ) 
    ,
    by = c("site", "year", "reach_survey_id")
  ) 
  
var_hab_site_year <- left_join(
  imwvar$transects_site_year |> select(-reach_survey_id)
  ,
  hab$transects_site_year |> select(-strm, -reach_survey_id)
  ,
  suffix = c("_var","_hab"),
  by = c("site", "year")
) |> select(
    cmplx_strm, site, year, 
    starts_with("n_pools"), starts_with("pct_pools"),
    starts_with("pool_wet_depth"), starts_with("pool_bnk_depth"),
    starts_with("pct_gravel"),
    starts_with("bnk_wdth"), starts_with("bnk_hght"),
    starts_with("wet_wdth"), starts_with("thl_dpth"),
    starts_with("bnk_w_bnk_d") #skipping wet_w_d
    )

```

```{r}
#immediate first impression is that site is biggest determinant of differences: 
#some sites are similar or different across multiple measures, likely transect-position related?
var_hab_site_year |> 
  select(cmplx_strm, site, pct_pools_var:pct_gravel_hab) |> 
  pivot_longer(-c(cmplx_strm, site)) |> 
  mutate(
    var_hab = str_sub(name, -3,-1),
    meas = str_sub(name, 1,-5),
    name = NULL
    ) |> 
  ggplot() +
  geom_col(aes(value, site, fill = var_hab), position = position_dodge()) +
  scale_fill_manual(values = c("purple","orange")) +
  facet_wrap(~meas, scales = "free")

#only the measures with single values, not yet examining min-max-mean
var_hab_site_year_diff <- var_hab_site_year |> 
  select(cmplx_strm, site, pct_pools_var:pct_gravel_hab) |> 
  pivot_longer(-c(cmplx_strm, site)) |> 
  mutate(
    var_hab = str_sub(name, -3,-1),
    meas = str_sub(name, 1,-5),
    name = NULL
    ) |> 
  pivot_wider(names_from = var_hab, values_from = value) |> 
  mutate(
    d_var_hab = var - hab,
    d_var_hab_pct_hab = d_var_hab / hab
  )
  
var_hab_site_year_diff |> 
  split(~meas) |> 
  map(
    ~.x |> 
      ggplot() +
      geom_boxplot(aes(d_var_hab, meas), outliers = F) +
      #geom_jitter(aes(d_var_hab, meas), height = 0.2, alpha = 0.5) +
      geom_text(aes(d_var_hab, meas, label = site), position = position_jitter(height = 0.2), alpha = 0.7, size = 3) +
      geom_vline(xintercept = 0, linetype = 2)
      #labs(title =  )
  ) |> 
  wrap_plots(ncol = 1)


#scatter 
var_hab_site_year_diff |> 
  ggplot() +
  geom_point(aes(var, hab)) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~meas, scales = "free")

#how do differences compare across measures



var_hab_site_year |> 
  filter(meas %in% c("pct_pools", "pool_bnk_depth_mean"))

  map(
    ~.x |> 
      ggplot() +
      geom_boxplot(aes(d_var_hab, meas), outliers = F) +
      #geom_jitter(aes(d_var_hab, meas), height = 0.2, alpha = 0.5) +
      geom_text(aes(d_var_hab, meas, label = site), position = position_jitter(height = 0.2), alpha = 0.7, size = 3) +
      geom_vline(xintercept = 0, linetype = 2)
      #labs(title =  )
  ) |> 
  wrap_plots(ncol = 1)


#min/mean/max

#cv

  

var_hab_tsct |> 
  filter(site == "BIB035") |> arrange(transect_letter) |> 
  mutate(pd = pool_var != pool_hab) |> 
  split(~pd)

#just the site center monumented transect, should be same location
var_hab_tsct |> 
  filter(tsct_lett == "F" & transect_letter == "F") |> 
  select(-starts_with("wet"), -starts_with("thl")) |> 
  #filter(pool_var != pool_hab)
  mutate(
    d_bnk_wdth = bnk_wdth_var - bnk_wdth_hab,
    d_bnk_hght = bnk_hght_var - bnk_hght_hab
  ) |> 
  arrange(desc(d_bnk_wdth)) |> #print(n = Inf)
  summarise(
    across(starts_with("d_"), list(mean = ~mean(abs(.))))
  )


var_hab_site_year |> 
  mutate(
    d_bnk_wdth_mean = bnk_wdth_mean_var - bnk_wdth_mean_hab #no bnk_hght in hab$transects_site_year
  ) |> 
  arrange(desc(d_bnk_wdth_mean)) |> 
  select(cmplx_strm:pct_pools_hab, starts_with("bnk_wdth_mean"), d_bnk_wdth_mean) |> 
  left_join(
    var_hab_tsct |> 
      filter(tsct_lett == "F" & transect_letter == "F") |> 
      mutate(d_bnk_wdth_F = bnk_wdth_var - bnk_wdth_hab) |> 
      select(site, year, d_bnk_wdth_F),
    by = c("site", "year")    
  ) |> 
  #print(n = Inf)
  #summarise(across(starts_with("d_"), list(mean = ~mean(abs(.)))))
  ggplot() +
  geom_boxplot(aes(d_bnk_wdth_mean, y = "site-year-mean")) +
  geom_boxplot(aes(d_bnk_wdth_F, y = "site-year-F"))



```



# was resto detectable treatment vs reference: whole-stream treat-ref diff series

```{r strm_year_meas_mean_diff_mean_trt_ref}
strm_year_meas_mean <- strm_year |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("pool_wet"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"), -contains("lwd_all"),
    -vlwd_mean
  ) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  mutate(cmplx = str_sub(cmplx_strm, 1,2))

diff_mean_trt_ref <- left_join(
  filter(strm_year_meas_mean, str_detect(cmplx_strm, "\\*", negate = T))
  ,
  filter(strm_year_meas_mean, str_detect(cmplx_strm, "\\*"))
  ,
  by = c("cmplx", "year", "name"), suffix = c("_trt","_ref")
  ) |> 
  mutate(dval = value_trt - value_ref)

```

```{r fig_trt_ref_diff_mean_cols}

diff_mean_trt_ref |> 
  ggplot(aes(year, dval, fill = cmplx_strm_trt, color = cmplx_strm_trt)) +
  geom_col(position = position_dodge()) +
  geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = 0) +
  #ggpmisc::stat_poly_line() +
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2", "p"))) +
  scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
  facet_grid(cols = vars(cmplx), rows = vars(name), scales = "free", axes = "all") +
  labs(title = "Annual differences, treatment less reference streams",
       subtitle = "Expect larger (abs) diffs with time (non-zero slopes) if actions detectable at whole-stream")
```

```{r fig_ref_series_trt_vert_segments}
diff_mean_trt_ref |> 
  ggplot(aes(year, fill = cmplx_strm_trt)) +
  geom_line(aes(y = value_ref, color = cmplx_strm_ref)) +
  geom_segment(aes(y = value_ref, yend = value_trt, color = cmplx_strm_trt),
               position = position_dodge(width = 0.4),
               linewidth = 1.1) +
  scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
  facet_grid(cols = vars(cmplx), rows = vars(name), 
             scales = "free", switch = "y", axes = "all") +
  theme_classic() +
  labs(
    x = NULL, y = NULL,
    title = "Whole-stream yearly mean values for reference (solid, dark lines) and treatment deviation (vertical segments)",
    subtitle = "Primarily illustrating that reference whole-stream summarized measures varied in time"
  )

```

```{r acf_coint}

strm_year_meas_mean |> 
  nest(.by = c(cmplx, cmplx_strm, name)) |> 
  mutate(
    acf1 = map_dbl(data, ~as.vector(acf(.x$value, na.action = na.pass, lag.max = 1)$acf)[2])
  ) |> 
  select(-data) |> 
  ggplot(aes(name, cmplx_strm)) +
  geom_point(aes(size = abs(acf1), color = acf1)) +
  geom_text(aes(label = round(acf1, 2))) +
  scale_size_area() +
  wacolors::scale_color_wa_c("lopez", midpoint = 0) 


diff_mean_trt_ref |> 
  nest(.by = c(cmplx_strm_trt, name)) |> 
  mutate(
    acf1 = map_dbl(data, ~as.vector(acf(.x$dval, na.action = na.pass, lag.max = 1)$acf)[2])
  ) |> 
  select(-data) |> 
  ggplot(aes(name, cmplx_strm_trt)) +
  geom_point(aes(size = abs(acf1), color = acf1)) +
  geom_text(aes(label = round(acf1, 2))) +
  scale_size_area() +
  wacolors::scale_color_wa_c("lopez", midpoint = 0) +
  labs(title = "Lag1 autcorr for treatment-reference difference series")


#https://www.econometrics-with-r.org/16.3-cointegration.html using ur.df
#https://www.quantstart.com/articles/Cointegrated-Augmented-Dickey-Fuller-Test-for-Pairs-Trading-Evaluation-in-R/ using tseries::adf.test
#cointegrated if both nonstationary series, and a cointegration coef theta (potentially theta==1) such that differences y[t] - theta*x[t] series is stationary

# z <- rep(0,100); for(i in 2:100){z[i] <- z[i-1] + rnorm(1)}
# zz <- tibble(t = 1:100, z = z, z2 = z + runif(100, 0.1, 2))
# ggplot(zz) + geom_line(aes(t, z)) + geom_line(aes(t, z2), color = 2)
# #adf null is nonstationary, p<crit rejects to conclude stationary
# tseries::adf.test(rnorm(100)) #stationary
# tseries::adf.test(zz$z) #nonstationary
# tseries::adf.test(zz$z2)#nonstationary


diff_mean_trt_ref |> 
  nest(.by = c(cmplx_strm_trt, name)) |> 
  mutate(
    adf_pval_trt = map_dbl(data, ~tseries::adf.test(na.omit(.x$value_trt))$p.value), #if this is nonstationary
    adf_pval_ref = map_dbl(data, ~tseries::adf.test(na.omit(.x$value_ref))$p.value), #and this is nonstationary
    adf_pval_d_trt_ref = map_dbl(data, ~tseries::adf.test(na.omit(.x$dval))$p.value), #but if this is stationary (theta = 1) then cointegrated
    adf_pval_d_trt_ref_k1 = map_dbl(data, ~tseries::adf.test(na.omit(.x$dval), k = 1)$p.value), #test statistic is sensitive to lag!
    #calculate theta (if not 1)
    lm_trt_ref = map(data, ~lm(value_trt ~ value_ref, data = .x)),
    #lm_theta = map_dbl(lm_trt_ref, ~.x$coefficients[2]),
    adf_pval_lm_resid = map_dbl(lm_trt_ref, ~tseries::adf.test(na.omit(.x$resid))$p.value),
    adf_pval_lm_resid_k1 = map_dbl(lm_trt_ref, ~tseries::adf.test(na.omit(.x$resid), k = 1)$p.value)
    # ,
    # adf_pval_urca_none = map(data, ~urca::ur.df(na.omit(.x$dval), type = "none", lags = 2, selectlags = "AIC")),
    # adf_pval_urca_drift = map(data, ~urca::ur.df(na.omit(.x$dval), type = "drift", lags = 2, selectlags = "AIC")),
    # adf_pval_urca_trend = map(data, ~urca::ur.df(na.omit(.x$dval), type = "trend", lags = 2, selectlags = "AIC"))
  ) |>
  select(-lm_trt_ref) |> 
  arrange(adf_pval_lm_resid_k1) |> 
#  filter(str_detect(cmplx_strm_trt, "Germany"), name == "pct_pools_mean")
  print(n = Inf) 

x <- diff_mean_trt_ref |> filter(str_detect(cmplx_strm_trt, "Germany"), name == "pct_gravel_mean") #gravel appears nonstationary s.t. not cointegrated, and tests above all fail to reject nonstationary, and test types below fail to reject null of nonstationary, so diffs nonstationary and not cointeg
x <- diff_mean_trt_ref |> filter(str_detect(cmplx_strm_trt, "Germany"), name == "pct_pools_mean") #visually pools diffs appears (more?) stationary, adftest above without lmtheta fails to reject nonstat but theta!=1 rejects nonstationarity, so stationary diffs and coint; but all these are nonsig fail to reject nonstat and not coint
urca::summary(urca::ur.df(x$dval, type = "none", lags = 2, selectlags = "AIC")) #fail to reject null nonstationary
urca::summary(urca::ur.df(x$dval, type = "drift", lags = 2, selectlags = "AIC"))
urca::summary(urca::ur.df(x$dval, type = "trend", lags = 2, selectlags = "AIC"))

urca::summary(urca::ur.kpss(x$dval, use.lag = 1)) #fail to reject stationary for pools, so in agreement with lmtheta adf.tests?; rejects stationary for gravel (so nonstationary diff, not coint)
tseries::kpss.test(x$dval) #same as ur.kpss, for pools fail to reject null stationary
tseries::adf.test(x$dval) #same as mapped version above, fails to reject nonstationary

```


# did whole-stream measure exhibit trend: series MK


# [and/but] was resto detectable at reach-scale: focal sites series


# across-site range distrib




# previous

```{r figSVN_site_range_ridges, fig.cap="Figure SVN: Stream network variation in temporal variation of habitat measures. Dots are range (max - min) for individual sites; lower interval bar shows IQR and among-site median (diamond). Asterisks designate 'control' streams in original study design."}
d <- site_meta |> #glimpse()
  #filter(year_n > 16) |> 
  select(cmplx_strm, site, 
         ends_with("min"), ends_with("max"), 
         -starts_with("year"), 
         -contains("lwd_all"), #only 'very' large wood
         -vlwd_min, -vlwd_max #use density not counts
         , -contains("bankfull_width")
         , -contains("wetted")
         , -contains("_m2")
         ) |> 
  pivot_longer(-c(cmplx_strm, site)) |> 
  mutate(
    m = str_sub(name, -3,-1), # m = map_chr(meas, ~last(str_split_1(.x,"_"))),
    name = str_remove(name, paste0("_",m)) # meas = map2_chr(meas, m, ~str_remove(.x, paste0("_",.y)))
  ) |> 
  pivot_wider(names_from = m, values_from = value) |> 
  mutate(
    site_rng = max - min,
  ) |> 
  drop_na(site_rng) |> 
  filter(is.finite(site_rng))

# d |> 
#   ggplot(mapping = aes(site_rng, fct_rev(cmplx_strm), color = cmplx_strm, fill = cmplx_strm)) +
#   geom_vline(xintercept = 0) +
#   ggridges::geom_density_ridges(
#     scale = 0.9,
#     alpha = 0.6,
#     show.legend = F) +
#   ggdist::stat_dots(
#     #this would work in a split/map pattern but with faceting here: aes(slab_alpha = after_stat(x)),
#     orientation = "horizontal",
#     alpha = 0.6,
#     show.legend = F
#   ) +
#   ggdist::stat_pointinterval(
#     orientation = "horizontal",
#     color = "black",
#     .width = c(0.5, 0.95),
#     shape = 3, #18,
#     fatten_point = 3,
#     show.legend = F
#   ) +
#   coord_cartesian(xlim = c(0, NA), ylim = c(0.7, NA), expand = F) +
#   scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
#   facet_wrap(~name, 
#              nrow = 1, #ncol = 3,
#              scales = "free_x") +
#   labs(
#     x = "", y = ""
#     ,
#     title = "Stream network variation in range of habitat measures through time",
#     subtitle = "Dots are range (max - min) for individual sites, interval shows median, IQR and 95% span"
#   )
# 
# ggsave(filename = "fig_SVN_site_range_ridges.png", width = 11, height = 9, dpi = 150, bg = "white")

d |> 
    mutate(
    cmplx_strm = factor(cmplx_strm, levels =   c(
      'HC_Little Anderson Creek','HC_Big Beef Creek','HC_Seabeck Creek','HC_Stavis Creek*',
      'LC_Germany Creek','LC_Abernathy Creek','LC_Mill Creek*',
      'ST_East Twin River','ST_West Twin River*','ST_Deep Creek'
    ))
    ,
    name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D"))
  ) |> 
  ggplot(mapping = aes(site_rng, fct_rev(cmplx_strm), color = cmplx_strm, fill = cmplx_strm)) +
  geom_vline(xintercept = 0) +
  ggridges::geom_density_ridges(
    scale = 0.9,
    alpha = 0.6,
    show.legend = F) +
  ggdist::stat_dots(
    #this would work in a split/map pattern but with faceting here: aes(slab_alpha = after_stat(x)),
    orientation = "horizontal",
    alpha = 0.6,
    show.legend = F
  ) +
  ggdist::stat_pointinterval(
    orientation = "horizontal",
    color = "black",
    .width = c(0.5, 0.95),
    shape = 3, #18,
    fatten_point = 3,
    show.legend = F
  ) +
  coord_cartesian(xlim = c(0, NA), ylim = c(0.7, NA), expand = F) +
  scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
  facet_wrap(~name, 
             nrow = 1, #ncol = 3,
             scales = "free_x") +
  labs(
    x = "", y = ""
    # ,
    # title = "Stream network variation in range of habitat measures through time",
    # subtitle = "Dots are range (max - min) for individual sites, interval shows median, IQR and 95% span"
  )

ggsave(filename = "fig_SVN_site_range_ridges2.png", width = 11, height = 9, dpi = 300, bg = "white")

```

```{r tabSNV_site_range_ridges, tab.cap="Table SNV: Mean, minimum, and maximum range per-site in habitat measures across streams."}
d_gt <- d |> 
  summarise(
    across(
      #c(min, max, site_rng), 
      site_rng,
      list(
        min = ~min(.,na.rm = T),
        mean = ~mean(.,na.rm = T),
        max = ~max(.,na.rm = T)
        )
      )
    ,.by = c(cmplx_strm, name)
  ) |>
  left_join(
    distinct(site_meta, cmplx_strm, cmplx_desc), by = "cmplx_strm"
  ) |> 
  pivot_wider(names_from = name, values_from = contains("site_rng")) |> 
  select(
    cmplx_desc, cmplx_strm, #strm,
    contains("width"), contains("W_D"), contains("gravel"), contains("pools"), contains("depth"), contains("vlwd")
  )

d_gt |> 
  gt(
    groupname_col = "cmplx_desc", 
    rowname_col = "cmplx_strm", 
    caption = "Mean, minimum, and maximum range per-site in habitat measures across streams"
    ) |> 
  fmt_number(where(is.numeric), decimals = 0) |> 
  fmt_number(contains("pool_depth"), decimals = 1) |> 
  fmt_number(contains("pct"), decimals = 2) |> 
#  tab_spanner("Bankfull W", contains("width")) |> 
  tab_spanner("BnkW:D", contains("W_D")) |> 
  tab_spanner("Ppn. gravel", contains("pct_gravel")) |> 
  tab_spanner("Ppn. pools", contains("pct_pool")) |> 
  tab_spanner("Pool depth", contains("pool_depth")) |> 
  tab_spanner("VLWD/100m", contains("per100")) |> 
  tab_spanner("VLWD vol.", contains("vol")) |> 
  cols_label_with(contains("min"), ~"min") |> 
  cols_label_with(contains("mean"), ~"mean") |> 
  cols_label_with(contains("max"), ~"max") |> 
  tab_style(
    style = list(cell_borders("left", weight = px(1.5))), 
    locations = cells_body(columns = contains("min"))
  ) |> 
  tab_style(
    style = list(cell_text(style = "italic")), 
    locations = map(3:17, 
      ~cells_body(columns = .x, rows = which.min(unlist(d_gt[,.x])))
    )
  ) |> 
  tab_style(
    style = list(cell_text(decorate = "underline")), 
    locations = map(3:17, 
      ~cells_body(columns = .x, rows = which.max(unlist(d_gt[,.x])))
    )
  )

```

In addition to the shared pattern of within-network heterogeneity in the magnitude of temporal variation, consistent directional change at the watershed scale was rarely detectable in the time series of habitat measures summarized across sites per year to a 'whole-stream' average (Table MK-strm-year, Figure MK-stream-year). Furthermore, with the exception of large wood in Abernathy Creek, the detectable trends were weak, failed to indicate separation between treatment and control streams, and did not necessarily suggest in-channel habitat improvement.

Mann-Kendall (MK) tests for trends in whole-stream interannual change were significant (p < 0.05) for the proportion of gravel substrate in Deep and East Twin Creeks (weakly positive slopes indicating increased gravel prevalence), for mean pool depth in Little Anderson and Deep Creeks (weakly negative slopes indicating shallower pools on average), and for large wood density in Abernathy Creek (modestly strong positive slope indicating increased wood prevalence).

Various individual sites did show statistically significant directional shifts through time in several measures (Figure MK-site-year). However, again with the exception of Abernathy Creek's large wood density change, these findings reinforced the conclusions at the scale of the whole-stream averages: relatively weak trends, little treatment-control separation, and little indication of desired habitat improvement.


```{r tabMK_strm_year, tab.cap="Mann-Kendall trend test results for interannual change in habitat measures, corrected for temporal autocorrelation. "}
#https://vsp.pnnl.gov/help/vsample/design_trend_mann_kendall.htm

strm_year_mk <- strm_year |> #glimpse()
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
    ) |> 
  # rename_with(~str_replace(., "_mean", "_stream_year_mean")) |> 
  rename_with(~str_remove(., "_mean")) |> 
  summarise(
    across(
        where(is.double),
        list(
          mk = ~list(rtrend::mkTrend(.))
          )
        ),
      .by = c(cmplx_strm)
    ) |> 
  unnest_wider(ends_with("_mk"), names_sep = ":") |> 
  select(cmplx_strm, ends_with("pval"), ends_with("slp"))

strm_year_mk |> 
  arrange(cmplx_strm) |> 
  left_join(distinct(site_meta, cmplx_strm, cmplx_desc), by = "cmplx_strm") |> 
  select(cmplx_desc, cmplx_strm, 
         ends_with("slp"), ends_with("pval"), #so that estimate is left of pval
         contains("width"), contains("W_D"), contains("gravel"), contains("pools"), contains("depth"), contains("per100"), contains("vol") #so that measures are side by side
         ) |> 
  gt(
    groupname_col = "cmplx_desc", 
    rowname_col = "cmplx_strm"
    #,caption = "Mann-Kendall trend test results for interannual change in habitat measures"
    ) |> 
  fmt_number(ends_with("pval"), decimals = 2) |> 
  fmt_number(ends_with("slp"), decimals = 4) |> 
#  tab_spanner("Bankfull W", contains("width")) |> 
  tab_spanner("BnkW:D", contains("W_D")) |> 
  tab_spanner("Ppn. gravel", starts_with("pct_gravel")) |> 
  tab_spanner("Ppn. pools", starts_with("pct_pool")) |> 
  tab_spanner("Pool depth", starts_with("pool_depth")) |> 
  tab_spanner("VLWD/100m", contains("per100")) |> 
  tab_spanner("VLWD vol.", contains("vol")) |> 
  cols_label_with(ends_with("slp"), ~"Sen's") |> 
  cols_label_with(ends_with("pval"), ~"p-val") |> 
  tab_style(style = cell_borders("left"), locations = cells_body(columns = ends_with("slp"))) |> 
  tab_style_body(
    style = list(cell_text(color = "red")), 
    columns = c(ends_with("slp"), ends_with("pval")),
    fn = \(x) x < 0 
  ) |> 
  tab_style_body(
    style = list(cell_fill("grey80"), cell_text(weight = "bold")), 
    columns = c(ends_with("pval")),
    fn = \(x) x <= 0.05 
  )
```

```{r figMK_strm_year, fig.cap="Time series of whole-stream average measures with Mann-Kendall test p-value < 0.05. "}
strm_year_mk |> 
  pivot_longer(-cmplx_strm) |> 
  separate(name, into = c("name","stat"), sep = "_mk:") |> 
  pivot_wider(names_from = stat, values_from = value) |> 
  filter(pval < 0.1) |>
  filter(pval < 0.05) |>
  mutate(cmplx_strm = as.character(cmplx_strm)) |> 
  arrange(name) |> 
  mutate(
    gg = map2(
      name, cmplx_strm,
      ~strm_year |> 
        filter(cmplx_strm == .y) |> 
        select(cmplx_strm, year, yval = all_of(paste0(.x,"_mean"))) |> 
        ggplot(aes(year, yval, color = cmplx_strm)) + 
        geom_line(linetype = 2, show.legend = F) + 
        geom_point(show.legend = F) + 
        #geom_smooth(se = F, show.legend = F) + 
        scale_color_manual(values = pal_cmplx_strm) +
        labs(x = "", y = .x, subtitle = .y)
    )
  ) |> 
  pull(gg) |> 
  wrap_plots(ncol = 4) #+plot_annotation(title = "Time series of measures with Mann-Kendall test p-value < 0.05")

#ggsave(filename = "fig_MK_strm_year.png", width = 11, height = 9, dpi = 150, bg = "white")
```

```{r figMK_site_year, fig.cap="Individual site very large wood density through time. Colored series indicate sites with significant (p < 0.05) Mann-Kendall trends, overlaid on the remaining sites (light gray)."}
site_year_mk <- site_year |> #glimpse()
  select(
    cmplx_strm, site, year, 
    bankfull_W_D, pct_gravel, pct_pools, pool_depth, vlwd_per100
    ) |> 
  summarise(
    across(
        where(is.double),
        list(
          mk = ~list(rtrend::mkTrend(.))
          )
        ),
      .by = c(cmplx_strm, site)
    ) |> 
  unnest_wider(ends_with("_mk"), names_sep = ":") |> 
  select(cmplx_strm, site, ends_with("pval"), ends_with("slp")) |> 
  pivot_longer(-c(cmplx_strm, site))

site_year |> 
  select(
    cmplx_strm, site, year, 
    bankfull_W_D, pct_gravel, pct_pools, pool_depth, vlwd_per100, vlwd_vol
  ) |> 
  pivot_longer(-c(cmplx_strm, site, year)) |> 
  #semi_join(
  left_join(
    site_year_mk |> 
      select(-cmplx_strm, site, name, pval = value) |> 
      filter(str_detect(name, "pval")) |>  #1345 site-measure tests
      filter(pval < 0.05) |> #166 'signif'
      #count(name) |> arrange(desc(n)) #most for wood
      #count(cmplx_strm) |> arrange(desc(n)) #most for Abernathy; note Deep and Stavis very similar to treatment streams in n-signif
      mutate(
        name = str_remove(name, "_mk:pval")
        )
    ,
    by = c("site","name")    
  ) |> 
  filter(name == "vlwd_per100") |> 
  split(~name) |> 
  map(
    ~ggplot(mapping = aes(year, value, group = site, color = cmplx_strm)) +
      geom_line(data = .x |> filter(is.na(pval)), color = "grey", linewidth = 0.2, show.legend = F) +
      geom_line(data = .x |> drop_na(pval), linewidth = 1.1, show.legend = F) +
      geom_point(data = .x |> drop_na(pval), size = 0.3, show.legend = F) +
      scale_color_manual(values = pal_cmplx_strm) +
      facet_wrap(~cmplx_strm, scales = "free") +
      labs(x = "", y = "", subtitle = .x$name[1])
  )

ggsave(filename = "fig_MK_site_year.png", width = 11, height = 9, dpi = 150, bg = "white")
```



```{r xlsx_export_for_KK}
list(
  strm_year = strm_year,
  strm_year_mk = strm_year_mk,
  site_meta = site_meta,
  site_year = site_year,
  site_year_mk = site_year_mk
) |> 
  writexl::write_xlsx("imw_hab_frontiers_mscpt_data_objects.xlsx")
```


```{r fig_strm_year_all, eval=FALSE}
strm_year |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
  ) |> 
  # rename_with(~str_replace(., "_mean", "_stream_year_mean")) |> 
  rename_with(~str_remove(., "_mean")) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  ggplot(aes(year, value, color = cmplx_strm)) + 
  geom_line(linetype = 2, show.legend = F) + 
  geom_point(size = 0.7, show.legend = F) + 
  #geom_smooth(se = F, show.legend = F) + 
  scale_color_manual(values = pal_cmplx_strm) +
  facet_wrap(~name + cmplx_strm, ncol = 10, scales = "free") +
  labs(x = "", y = "", subtitle = "Time series of whole stream mean across sites per year")

ggsave(filename = "fig_strm_year_all.png", width = 16, height = 12, dpi = 150, bg = "white")
```

```{r fig_strm_year_all2, eval=FALSE}
#portrait, reordered streams, fixed y-axis scales by measure

strm_year |> 
  mutate(
    cmplx_strm = factor(cmplx_strm, levels =   c(
      'HC_Little Anderson Creek','HC_Big Beef Creek','HC_Seabeck Creek','HC_Stavis Creek*',
      'LC_Germany Creek','LC_Abernathy Creek','LC_Mill Creek*',
      'ST_East Twin River','ST_West Twin River*','ST_Deep Creek'
    )
    )
  ) |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
  ) |> 
  rename_with(~str_remove(., "_mean")) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  mutate(
    name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D"))
  ) |> 
  split(~name) |> 
  map(
    ~.x |> 
  ggplot(aes(year, value, color = cmplx_strm)) +
  geom_line(linetype = 2, show.legend = F) +
  geom_point(size = 0.7, show.legend = F) +
  scale_color_manual(values = pal_cmplx_strm) +
  facet_wrap(~cmplx_strm + name, nrow = 10, scales = "fixed") +
    labs(x = NULL, y = NULL)
  ) |> 
  wrap_plots(ncol = 6)

  # ggplot(aes(year, value, color = cmplx_strm)) + 
  # geom_line(linetype = 2, show.legend = F) + 
  # geom_point(size = 0.7, show.legend = F) + 
  # #geom_smooth(se = F, show.legend = F) + 
  # scale_color_manual(values = pal_cmplx_strm) +
  # #facet_wrap(~cmplx_strm + name, nrow = 10, scales = "fixed") +
  # facet_grid(rows = vars(cmplx_strm), cols = vars(name), scales = "free_y") +
  # labs(x = "", y = "", subtitle = "Time series of whole stream mean across sites per year")

ggsave(filename = "fig_strm_year_all2.png", width = 12, height = 16, dpi = 150, bg = "white")
```

```{r fig_strm_year_all3, eval=FALSE}
#portrait, reordered streams, fixed y-axis scales by measure
#higher res, better facet labeling, theme_classic

csl <- c(
      'HC_Little Anderson Creek','HC_Big Beef Creek','HC_Seabeck Creek','HC_Stavis Creek*',
      'LC_Germany Creek','LC_Abernathy Creek','LC_Mill Creek*',
      'ST_East Twin River','ST_West Twin River*','ST_Deep Creek'
    )

{
  ggplot(tibble(cmplx_strm = factor(csl, levels = csl))) + 
    geom_text(aes(1,1,label = cmplx_strm), size = 3) + 
    facet_wrap(~cmplx_strm, nrow = 10, scales = "fixed") + 
    theme_void() + theme(strip.text = element_blank())
} + {
strm_year |> 
  mutate(
    cmplx_strm = factor(cmplx_strm, levels = csl)
  ) |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
  ) |> 
  rename_with(~str_remove(., "_mean")) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  mutate(
    name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D"))
  ) |> 
  split(~name) |> 
  map(
    ~.x |> 
  ggplot(aes(year, value, color = cmplx_strm)) +
  geom_line(linetype = 2, show.legend = F) +
  geom_point(size = 0.7, show.legend = F) +
  scale_color_manual(values = pal_cmplx_strm) +
  facet_wrap(~cmplx_strm, nrow = 10, scales = "fixed", axes = "all") +
    theme_classic() +
    theme(strip.text = element_blank()) +
    labs(
      subtitle = .x$name[1],
      x = NULL, y = NULL
      )
  ) |> 
  wrap_plots(ncol = 6)
} + 
  plot_layout(widths = c(0.1,0.9))


ggsave(filename = "fig_strm_year_all3.png", width = 12, height = 16, dpi = 300, bg = "white")
```

```{r fig_strm_year_all4NOTRUN, eval=FALSE}
#back to a version overlaying streams in complexes
#portrait, reordered streams, fixed y-axis scales by measure
#higher res, better facet labeling, theme_classic


csl <- c(
      'HC:\nLittle Anderson Creek\nBig Beef Creek\nSeabeck Creek\nStavis Creek*',
      'LC:\nGermany Creek\nAbernathy Creek\nMill Creek*',
      'ST:\nEast Twin River\nWest Twin River*\nDeep Creek'
    )

{
  ggplot(tibble(cmplx_strm = factor(csl, levels = csl))) +
    geom_text(aes(1,1,label = cmplx_strm), size = 3) +
    facet_wrap(~cmplx_strm, nrow = 3, scales = "fixed") +
    theme_void() + theme(strip.text = element_blank())
}+{
strm_year |> 
  # mutate(
  #   cmplx_strm = factor(cmplx_strm, levels = csl)
  # ) |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
  ) |> 
  rename_with(~str_remove(., "_mean")) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  mutate(
    cmplx = str_sub(cmplx_strm, 1,2),
    name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D"))
  ) |> 
  split(~name) |> 
  map(
    ~.x |> 
  ggplot(aes(year, value, color = cmplx_strm)) +
  geom_line(linetype = 1, linewidth = 0.2, show.legend = F) +
  geom_point(size = 0.7, show.legend = F) +
  scale_color_manual(values = pal_cmplx_strm) +
  facet_wrap(~cmplx, nrow = 3, scales = "fixed", axes = "all") +
    theme_classic() +
    theme(strip.text = element_blank()) +
    labs(
      subtitle = .x$name[1],
      x = NULL, y = NULL
      )
  ) |> 
  wrap_plots(ncol = 6)
} + 
  plot_layout(widths = c(0.1,0.9))


ggsave(filename = "fig_strm_year_all4.png", width = 12, height = 16, dpi = 300, bg = "white")
```

```{r fig_strm_year_all_IQR}

strm_year |> 
  mutate(cmplx_strm = factor(cmplx_strm, levels = csl)) |> 
  select(
    cmplx_strm, year, ends_with("5"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_q25, -lwd_all_q75,
    -lwd_all_per100_q25, -lwd_all_per100_q75, 
    -vlwd_q25, -vlwd_q75 
  ) |>
  pivot_longer(-c(cmplx_strm, year)) |> 
  separate(name, into = c("name","q"), sep = "_q") |> 
  pivot_wider(names_from = q, values_from = value) |> 
  mutate(
    name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D")),
    iqr = `75`-`25`
  ) |> 
  select(cmplx_strm, year, name, iqr) |> 
    split(~name) |> 
  map(
    ~.x |> 
  ggplot(aes(year, iqr, color = cmplx_strm)) +
  geom_line(linetype = 2, show.legend = F) +
  geom_point(size = 0.7, show.legend = F) +
  scale_color_manual(values = pal_cmplx_strm) +
  facet_wrap(~cmplx_strm, nrow = 10, scales = "fixed", axes = "all") +
    theme_classic() +
    #theme(strip.text = element_blank()) +
    labs(
      subtitle = .x$name[1],
      x = NULL, y = NULL
      )
  ) |> 
  wrap_plots(ncol = 6)
  
ggsave(filename = "fig_strm_year_all_IQR.png", width = 12, height = 16, dpi = 150, bg = "white")

```


```{r}
#did treatment streams diverge from reference streams?
d_mean <- strm_year |> 
  select(
    cmplx_strm, year, ends_with("_mean"),
    -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
    -lwd_all_mean, -lwd_all_per100_mean, -vlwd_mean
  ) |> 
  #rename_with(~str_remove(., "_mean")) |> 
  pivot_longer(cols = -c(cmplx_strm, year)) |> 
  mutate(
    cmplx = str_sub(cmplx_strm, 1,2)
    #,name = factor(name, levels = c("vlwd_per100","vlwd_vol","pct_pools","pool_depth","pct_gravel","bankfull_W_D"))
  )

d_mean_trt_ref <- left_join(
  filter(d_mean, str_detect(cmplx_strm, "\\*", negate = T))
  ,
  filter(d_mean, str_detect(cmplx_strm, "\\*"))
  ,
  by = c("cmplx", "year", "name"), suffix = c("_trt","_ref")
  ) |> 
  mutate(
    dval = value_trt - value_ref
  )

d_mean_trt_ref |> 
  ggplot(aes(year, dval, fill = cmplx_strm_trt, color = cmplx_strm_trt)) +
  geom_col(position = position_dodge()) +
  geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = 0) +
  #ggpmisc::stat_poly_line() +
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2", "p"))) +
  scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
  facet_grid(cols = vars(cmplx), rows = vars(name), scales = "free", axes = "all") +
  labs(title = "Annual differences, treatment versus reference streams", subtitle = "Expect larger diffs with time (non-zero slopes) if actions detectable at whole-stream")

#playing with displaying differences on top of reference series 
#maybe cool but arguably not really that helpful?
d_mean_trt_ref |> 
  ggplot(aes(year, fill = cmplx_strm_trt, color = cmplx_strm_trt)) +
  geom_line(aes(y = value_ref, color = cmplx_strm_ref)) +
  #geom_point(aes(y = value_trt)) +
  geom_segment(aes(y = value_ref, yend = value_trt), position = position_dodge(width = 0.3)) +
  scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
  facet_grid(cols = vars(cmplx), rows = vars(name), scales = "free", axes = "all")


#every measure, each stream fit individually s.t. year is per-stream slope
d_mean_trt_ref |> 
  nest(.by = c(cmplx_strm_trt, name)) |> 
  mutate(
    lm_fit = map(data, ~lm(dval ~ year, data = .x)),
    lm_est_year = map(lm_fit, ~broom::tidy(.x) |> filter(term=="year"))
  ) |> 
  unnest_wider(lm_est_year) |> 
  arrange(p.value)

#every measure, streams as factor for different intercepts plus shared year effect AND stream-specific slope
d_mean_trt_ref |> 
  nest(.by = c(cmplx, name)) |> 
  mutate(
    lm_fit = map(data, ~lm(dval ~ year + cmplx_strm_trt + year:cmplx_strm_trt, data = .x)),
    lm_est_year = map(lm_fit, ~broom::tidy(.x))
  ) |> 
  unnest_longer(lm_est_year) |> 
  select(-data, -lm_fit) |> print(n = Inf)



#couple of other presentations beside lm(dval ~ year): cumulative and average diff
#these inform overall magnitude of departure (are differences small)
#but do not capture change in time (are differences getting larger)
d_mean_trt_ref |> 
  #nest(.by = c(cmplx_strm_trt, name)) |> 
  summarise(
    across(dval, list(
      sum = ~sum(.),
      mean = ~mean(.),
      abs_mean = ~mean(abs(.))
    )),
    .by = c(cmplx, cmplx_strm_trt, name)
  )

# #redo as var/IQR
# #look similar to means but probably harder to think about?
# #positive cols are larger IQR in treatment, neg slope less positive but greater than zero indicates smaller variation in treatment
# #negative cols are smaller IQR in treatment such that pos slope less negative is increasing var in treatment (or shrinking in ref) etc.
# d_iqr <- strm_year |> 
#   select(
#     cmplx_strm, year, ends_with("5"),
#     -contains("lgth"), -contains("_m2"), -contains("bankfull_width"),
#     -lwd_all_q25, -lwd_all_q75,
#     -lwd_all_per100_q25, -lwd_all_per100_q75, 
#     -vlwd_q25, -vlwd_q75 
#   ) |>
#   pivot_longer(-c(cmplx_strm, year)) |> 
#   separate(name, into = c("name","q"), sep = "_q") |> 
#   pivot_wider(names_from = q, values_from = value) |> 
#   mutate(
#     cmplx = str_sub(cmplx_strm, 1,2),
#     iqr = `75`-`25`
#     )
# 
# d_iqr_trt_ref <- left_join(
#   filter(d_iqr, str_detect(cmplx_strm, "\\*", negate = T)) |> select(-`25`,-`75`)
#   ,
#   filter(d_iqr, str_detect(cmplx_strm, "\\*")) |> select(-`25`,-`75`)
#   ,
#   by = c("cmplx", "year", "name"), suffix = c("_trt","_ref")
#   ) |> 
#   mutate(
#     dval = iqr_trt - iqr_ref
#   )
# 
# d_iqr_trt_ref |> 
#   ggplot(aes(year, dval, fill = cmplx_strm_trt, color = cmplx_strm_trt)) +
#   geom_col(position = position_dodge()) +
#   geom_smooth(method = "lm", se = F) +
#   geom_hline(yintercept = 0) +
#   #ggpmisc::stat_poly_line() +
#   ggpmisc::stat_poly_eq(ggpmisc::use_label(c("adj.R2", "p"))) +
#   scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
#   facet_grid(cols = vars(cmplx), rows = vars(name), scales = "free", axes = "all") +
#   labs(title = "Annual IQR anomalies versus reference streams")

```


```{r}
#https://stats.stackexchange.com/questions/576499/how-to-compare-two-time-series-with-a-gam
#instead of single fits per treatment stream against ref
#model treatment streams as factors, pooled over complex

d <- d_mean_trt_ref |> 
  filter(cmplx == "LC", name == "vlwd_per100_mean") |> 
  #filter(cmplx == "LC", name == "pct_gravel_mean") |> 
  mutate(year = year - 2006)

#ignoring individual treatment streams, not useful
lm(dval ~ year, data = d) |> summary()
#intercept differs by stream but same relationship to time
lm(dval ~ year + cmplx_strm_trt, data = d) |> summary()
#intercept and slope differ with time plus shared per-year effect
lm(dval ~ year + cmplx_strm_trt + year:cmplx_strm_trt, data = d) |> 
  #summary()
  broom::glance()
#intercept and slope-against-time differ, no common time effect
#with only 2 levels to stream these are effectively the same
lm(dval ~ cmplx_strm_trt + year:cmplx_strm_trt, data = d) |> 
    #summary()
  broom::glance()
#with fixed year effects, no "slope"
lm(dval ~ factor(year) + cmplx_strm_trt, data = d) |> summary()

#panel or repeat measures or longitudinal study regression?
#https://www.econometrics-with-r.org/10.4-regression-with-time-fixed-effects.html
# #if I had a worthwhile independent measure of "restored" could do something like
# lm(dval ~ resto_amount + cmplx_strm_trt + year:cmplx_strm_trt, data = d)
# # or use plm::plm, but I don't so I can't


```



```{r gg_site_range_horiz_cascade, eval=FALSE}
d |>
  split(~name) |>
  map(
    ~.x |> 
      drop_na(min) |> 
      ggplot() +
      geom_linerange(
        aes(xmin = min, xmax = max,
            y = fct_reorder(site, min, .fun = "min"),
            color = cmplx_strm)
        , show.legend = F
      ) +
      scale_color_manual(values = pal_cmplx_strm, aesthetics = c("color","fill")) +
      labs(y = "", subtitle = .x$name[1])
  )  # wrap_plots(nrow = 1)

```

```{r gg_strm_year_pointrange_series_grid, eval=FALSE}
strm_year |> #glimpse()
  select(cmplx_strm, year,
         ends_with("min"), ends_with("mean"), ends_with("max"), 
         -contains("lwd_all"), 
         -vlwd_min, -vlwd_mean, -vlwd_max #use density not counts 
         ,-contains("up_down"),-contains("bankfull_width")
  ) |> 
  pivot_longer(-c(cmplx_strm, year)) |> 
  mutate(
    m = str_sub(name, -3,-1),
    m = if_else(m == "ean","mean",m), #quickfix 
    name = str_remove(name, paste0("_",m)) 
  ) |> 
  pivot_wider(names_from = m, values_from = value) |> 
  ggplot(aes(year, mean, color = cmplx_strm)) +
  geom_line(linetype = 2, linewidth = 0.5, show.legend = F) +
  geom_linerange(aes(ymin = min, ymax = max), linewidth = 0.5, show.legend = F) +
  #geom_linerange(aes(ymin = q25, ymax = q75), linewidth = 1.2, show.legend = F) +
  geom_point(show.legend = F) +
  scale_color_manual(values = pal_cmplx_strm) +
  facet_grid(cols = vars(cmplx_strm), rows = vars(name), scales = "free") +
  labs(
    x = "", y = "",
    title = "Whole-stream per-year means across sites"
  )

ggsave(filename = "fig_strm_year_pointrange_series_grid.png", width = 16, height = 12, dpi = 150, bg = "white")
```

```{r strm_year_ts_kpss, eval=FALSE}
# library(tsibble)
# library(feasts) #loads: library(fabletools)
# library(fable)
#https://feasts.tidyverts.org/

strm_year_ts <- d |> 
  tsibble::as_tsibble(key = cmplx_strm, index = year)

# strm_year_ts |> fabletools::features(c(pct_gravel_mean), features = quantile)
# strm_year_ts |> fabletools::features(c(pct_gravel_mean), features = list(quantile, mu = mean))
# strm_year_ts |> fabletools::features(c(pct_gravel_mean), features = feat_acf)
# # # STL (via loess) not appropriate for yearly data, with no meaningful 'season'?
# # #also "trend_strength" is relative to 'seasonal' component, not really "slope magnitude"
# # strm_year_ts |> fabletools::features(c(pct_gravel_mean), features = feasts::feat_stl)
# 
# #gravel MK signif (pos) for Deep and E-twin
# strm_year_ts |> fabletools::features(c(pct_gravel_mean), features = unitroot_kpss) |> arrange(kpss_pvalue)

strm_year_ts_kpss <- strm_year_ts |>
  pivot_longer(-c(cmplx_strm, year)) |> 
  split(~name) |> 
  map(
    ~fabletools::features(.x, value, features = feasts::unitroot_kpss) |> 
      mutate(name = .x$name[1])
      #rename_with(~paste(.x$name[1],.,sep = "_"), starts_with("kpss"))
    ) |> 
  bind_rows()

strm_year_ts_kpss |> 
  # filter(kpss_pvalue < 0.05)
  pivot_wider(names_from = name, values_from = starts_with("kpss")) |> 
  left_join(distinct(site_meta, cmplx_strm, cmplx_desc), by = "cmplx_strm") |> 
  select(cmplx_desc, cmplx_strm, 
         #contains("stat"), contains("pval"), #so that estimate is left of pval
         contains("width"), contains("W_D"), contains("gravel"), contains("pools"), contains("depth"), contains("vlwd") #so that measures are side by side
  ) |> 
  gt(
    groupname_col = "cmplx_desc", 
    rowname_col = "cmplx_strm", 
    caption = "KPSS test results for interannual stationarity in habitat measures"
  ) |> 
  fmt_number(contains("pvalue"), decimals = 2) |> 
  fmt_number(contains("stat"), decimals = 2) |> 
  tab_spanner("Bankfull W", contains("width")) |> 
  tab_spanner("BnkW:ThalD", contains("W_D")) |> 
  tab_spanner("Ppn. gravel", contains("pct_gravel")) |> 
  tab_spanner("Ppn. pools", contains("pct_pool")) |> 
  tab_spanner("Pool depth", contains("pool_depth")) |> 
  tab_spanner("VLWD/100m", contains("vlwd")) |> 
  cols_label_with(contains("stat"), ~"Stat.") |> 
  cols_label_with(contains("pval"), ~"p-val") |> 
  tab_style(style = cell_borders("left"), locations = cells_body(columns = contains("stat"))) |> 
  tab_style_body(
    style = list(cell_text(color = "red")), 
    columns = c(contains("stat"), contains("pvalue")),
    fn = \(x) x < 0 
  ) |> 
  tab_style_body(
    style = list(cell_fill("grey80"), cell_text(weight = "bold")), 
    columns = c(contains("pvalue")),
    fn = \(x) x <= 0.05 
  )

```

```{r dew765, eval=FALSE}
site_year |> filter(site == "DEW765") |> ggplot(aes(year, vlwd_per100)) + geom_line() + geom_point()

sf_site_year |> 
  filter(site == "DEW765") |> 
  ggplot() +
  #geom_sf_text(data = sf_site_meta |> filter(site == "DEW765"), aes(label = site)) +
  geom_sf(data = sf_site_year |> filter(site == "DEW765") |> select(site), color = "grey", alpha = 0.5) +
  geom_sf(aes(size = vlwd)) +
  facet_wrap(~year)

```

